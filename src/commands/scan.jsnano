import fg from 'fast-glob';
import pc from 'picocolors';
import { writeJSON, ensureDir, writeText, exists } from '../utils/fs.js';
import { basename, resolve } from 'node:path';
import { readFile } from 'node:fs/promises';

const CACHE_DIR = '.sweepstacx';
const CACHE_FILE = `${CACHE_DIR}/scan.json`;

export default async function scanCmd({ path = '.', lang = 'js', verbose = false }) {
  const root = resolve(process.cwd(), path);
  if (verbose) console.log(pc.dim(`Scanning ${root} (lang=${lang})`));

  const exts = lang === 'py' ? ['py'] : ['js', 'jsx', 'ts', 'tsx'];
  const patterns = exts.map((e) => `**/*.${e}`);
  const ignore = ['**/node_modules/**', '**/dist/**', '**/build/**', '**/.next/**', '**/.git/**'];
  const files = await fg(patterns, { cwd: root, ignore, dot: false, absolute: true });

  const stats = {
    files_scanned: files.length,
    dead_files: 0,
    unused_imports: 0,
    duplicate_blocks: 0,
    stale_configs: 0,
    loc_removed: 0
  };

  const issues = [];
  const smallFileMap = new Map();

  for (const f of files) {
    const rel = f.replace(`${root}/`, '');
    let text = '';
    try { text = await readFile(f, 'utf8'); } catch { continue; }

    // naive unused import signal
    const importMatches = [...text.matchAll(/^import\s+([^'"]+)\s+from\s+['"][^'"]+['"];?/gm)];
    for (const m of importMatches) {
      const raw = m[1].trim();
      const token = raw.replace(/[{}]/g, '').split(',')[0].trim();
      if (token && !new RegExp(`\\b${escapeRegex(token)}\\b`).test(text.replace(m[0], ''))) {
        stats.unused_imports++;
        issues.push({ type: 'unused_import', file: rel, token });
      }
    }

    // tiny duplicate heuristic
    if (text.length > 0 && text.length <= 200) {
      const key = `${basename(f)}:${hashStr(text)}`;
      if (smallFileMap.has(key)) {
        stats.duplicate_blocks++;
        issues.push({ type: 'duplicate_block', file: rel, duplicate_of: smallFileMap.get(key) });
      } else {
        smallFileMap.set(key, rel);
      }
    }
  }

  const payload = {
    repo: basename(root),
    root,
    scanned_at: new Date().toISOString(),
    stats,
    issues,
    patches: []
  };

  await ensureDir(CACHE_DIR);
  await writeJSON(CACHE_FILE, payload);
  await writeText(`${CACHE_DIR}/.last`, String(Date.now()));

  console.log(pc.green(`âœ“ Scan complete.`), pc.dim(`files=${files.length}, unused_imports=${stats.unused_imports}, duplicates=${stats.duplicate_blocks}`));
  if (!(await exists(CACHE_FILE))) throw new Error('Failed to write scan cache.');
}

function escapeRegex(s) { return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
function hashStr(s) { let h=0; for (let i=0;i<s.length;i++) h=(h<<5)-h+s.charCodeAt(i)|0; return (h>>>0).toString(16); }
