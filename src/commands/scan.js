import fg from 'fast-glob';
import { readFile, writeFile } from 'node:fs/promises';
import { resolve, relative } from 'node:path';

export default async function runScan(opts = {}) {
  const root = resolve(process.cwd(), opts.path || '.');

  const files = await fg(
    [`${root}/**/*.js`, `${root}/**/*.mjs`, `${root}/**/*.cjs`],
    { ignore: ['**/node_modules/**','**/dist/**','**/coverage/**','**/.git/**'], dot: false }
  );

  const warnings = [];
  if (files.length === 0) {
    const msg = 'No files matched scan patterns (*.js, *.mjs, *.cjs). Check --path or ignore globs.';
    warnings.push(msg);
    console.warn('⚠️  ' + msg);
  }

  const issues = [];
  for (const file of files) {
    const src = await readFile(file, 'utf8');
    const unused = detectUnusedImports(src);
    for (const sym of unused) {
      issues.push({
        type: 'unused_import',
        file: relative(process.cwd(), file),
        symbol: sym,
      });
    }
  }

  const stats = {
    files_scanned: files.length,
    unused_imports: issues.filter(i => i.type === 'unused_import').length,
    duplicate_blocks: 0,
    dead_files: 0,
    stale_configs: 0,
  };

  const report = {
    meta: { tool: 'SweepstacX', version: '0.1.7', scanned_at: new Date().toISOString(), root },
    warnings,
    stats,
    issues
  };

  await writeFile(resolve(process.cwd(), 'sweepstacx-report.json'), JSON.stringify(report, null, 2));
  await writeFile(resolve(process.cwd(), 'sweepstacx-report.md'), renderMarkdown(report), 'utf8');

  console.log(`✓ Scan complete. files=${stats.files_scanned}, unused_imports=${stats.unused_imports}, duplicates=${stats.duplicate_blocks}${warnings.length ? `, warnings=${warnings.length}` : ''}`);
}

/**
 * Unused import detector (indent + multi-line; skips side-effect imports)
 */
function detectUnusedImports(code) {
  const unused = [];
  const re = /^\s*import\s+(?!['"])([\s\S]*?)\s+from\s+['"][^'"]+['"]/gm;

  let m;
  while ((m = re.exec(code))) {
    const clause = m[1].trim();

    // namespace: import * as ns from 'x'
    const nsMatch = clause.match(/^\*\s+as\s+([A-Za-z_$][\w$]*)$/);
    if (nsMatch) {
      if (!isUsed(code, nsMatch[1], m.index, m[0].length)) unused.push(nsMatch[1]);
      continue;
    }

    // default + named
    let defaultName = null;
    let namedBlock = null;
    const firstComma = topLevelCommaIndex(clause);

    if (firstComma === -1) {
      if (clause.startsWith('{')) namedBlock = clause;
      else defaultName = clause;
    } else {
      defaultName = clause.slice(0, firstComma).trim();
      namedBlock  = clause.slice(firstComma + 1).trim();
    }

    if (defaultName && !defaultName.startsWith('{')) {
      if (!isUsed(code, defaultName, m.index, m[0].length)) unused.push(defaultName);
    }

    if (namedBlock) {
      const inner = (namedBlock.match(/\{([^}]*)\}/) || [,''])[1];
      for (const raw of inner.split(',').map(s => s.trim()).filter(Boolean)) {
        const alias = raw.match(/^([A-Za-z_$][\w$]*)\s+as\s+([A-Za-z_$][\w$]*)$/i);
        const name = alias ? alias[2] : raw;
        if (name && !isUsed(code, name, m.index, m[0].length)) unused.push(name);
      }
    }
  }

  return unused;
}

function topLevelCommaIndex(s) {
  let depth = 0;
  for (let i = 0; i < s.length; i++) {
    const ch = s[i];
    if (ch === '{') depth++;
    else if (ch === '}') depth--;
    else if (ch === ',' && depth === 0) return i;
  }
  return -1;
}

function isUsed(code, ident, importStart, importLen) {
  const before = code.slice(0, importStart);
  const after  = code.slice(importStart + importLen);
  const body   = before + '\n' + after;
  const reWord = new RegExp(`\\b${escapeRegExp(ident)}\\b`, 'g');
  return reWord.test(body);
}

function escapeRegExp(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function renderMarkdown(report) {
  const s = report.stats;
  const lines = [
    `# SweepstacX — Scan Report`,
    ``,
    `**Scanned at:** ${report.meta.scanned_at}`,
    ``
  ];

  if (report.warnings && report.warnings.length) {
    lines.push(`## Warnings`);
    for (const w of report.warnings) lines.push(`- ${w}`);
    lines.push('');
  }

  lines.push(
    `## Summary`,
    `- Files scanned: **${s.files_scanned}**`,
    `- Dead files: **${s.dead_files}**`,
    `- Unused imports: **${s.unused_imports}**`,
    `- Duplicate blocks: **${s.duplicate_blocks}**`,
    `- Stale configs: **${s.stale_configs}**`,
    ``,
    `## Issues`
  );

  if (s.unused_imports === 0) {
    lines.push(`_No unused imports detected._`);
  } else {
    for (const i of report.issues.filter(i => i.type === 'unused_import')) {
      lines.push(`- Unused import \`${i.symbol}\` in \`${i.file}\``);
    }
  }

  lines.push('', `_Generated by SweepstacX v${report.meta.version}_`, '');
  return lines.join('\n');
}
